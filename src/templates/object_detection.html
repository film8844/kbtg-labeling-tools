{% extends "base.html" %}
{% block css %}
<style>
    #vertical-guide,
    #horizontal-guide {
        position: absolute;
        background-color: gray;
        pointer-events: none;
        /* ensures the guidelines don't interfere with other mouse events */
        display: none;
        /* hide them by default */
        z-index: 10;
        /* position them above other elements, adjust as needed */
    }

    #vertical-guide {
        width: 1px;
        height: 100%;

        top: 0;
    }

    #horizontal-guide {
        height: 1px;
        width: 100%;

        left: 0;
    }


    #image-container {
        position: absolute;
        /* height: 75vh; */
        /* overflow: scroll; */
        /* background-color: #fff; */
    }

    #zoom-control {
        position: relative;
        background-color: #fff;
        height: 75vh;
        overflow: hidden;
    }

    #image-container :hover {
        cursor: crosshair;
    }

    #zoom-controls {
        height: 100%;
        /* overflow: auto; */
    }

    /* #image :hover {
        cursor: crosshair;
        /* z-index: 999 !important; */
    }

    */ #image {
        position: relative;

    }


    .annotation {
        position: absolute;
        border: 2px solid red;
        background-color: rgba(255, 0, 0, 0.2);
        z-index: 2;
    }

    .annotation :hover {
        cursor: pointer !important;
    }

    .annotation :hover .resize-handle {
        display: block;
    }

    .annotation.selected {
        border: 2px dashed gray;
    }

    select option[selected] {
        background-color: '#fff'
    }

    .resize-handle {
        cursor: pointer;
        z-index: 4;
    }

    .form-popup {
        display: none;
        position: fixed;
        bottom: 20vh;
        right: 20vw;
        border: 3px solid #f1f1f1;
        z-index: 9;
    }
</style>
{% endblock %}

{% block content %}

<div class="row">
    <!-- Tools -->
    <div class="col-1">
        <div class="col-lg-12">
            <div class="card">
                <div class="card-body align-center text-center">
                    <!-- <h5 class="card-title">Label</h5> -->
                    <div class="mt-2">
                        <button id="draw-mode" class="btn btn-primary" data-bs-toggle="tooltip"
                            data-bs-placement="right" title="R: Rectangle Mode"><i class="bx bx-selection"></i></button>
                    </div>
                    <div class="mt-2">
                        <button id="edit-mode" class="btn btn-primary" data-bs-toggle="tooltip"
                            data-bs-placement="right" title="E: Edit Mode"><i class="bx bxs-edit"></i></button>
                    </div>
                    <div class="mt-2">
                        <button id="zoom-in" class="btn btn-secondary" data-bs-toggle="tooltip"
                            data-bs-placement="right" title="Zoom in"><i class="bi bi-zoom-in"></i></button>
                    </div>
                    <div class="mt-2">
                        <button id="zoom-out" class="btn btn-secondary" data-bs-toggle="tooltip"
                            data-bs-placement="right" title="Zoome out"><i class="bi bi-zoom-out"></i></button>
                    </div>
                    <div class="mt-2">
                        <button id="delete-button" class="btn btn-danger" data-bs-toggle="tooltip"
                            data-bs-placement="right" title="Delete selection"><i class="bx bxs-trash"></i></button>
                    </div>
                    <div class="mt-2">
                        <button id="reset-button" class="btn btn-danger" data-bs-toggle="tooltip"
                            data-bs-placement="right" title="Reset"><i class="bx bx-revision"></i></button>
                    </div>
                    <!-- <h5 class="card-title">Zoom Level: <span id="zoom-level">100</span>%</h5> -->
                    <!-- <div id="zoom-controls" class="mb-2">
                        <button id="zoom-in" class="btn btn-primary"><i class="bi bi-zoom-in"></i></button>
                    </div> -->
                </div>
            </div>
        </div>
    </div>

    <!-- Annotation  -->
    <div class="col-11">
        <div class="row">
            <div class="col-10 p-0" id="zoom-control">
                <div id="vertical-guide"></div>
                <div id="horizontal-guide"></div>
                <div id="image-container">

                    <img id="image" draggable="false" src="../{{task.path}}" alt="Image for annotation">
                    <div id="annotation-list"></div>

                </div>

            </div>
            <div class="col-2 p-1">
                <div class="col-lg-12">
                    <div class="card">
                        <h5 class="card-title m-2">Annotation List</h5>
                        <div style="height: 33vh;overflow: auto;" id="annotation-list" class="card-body p-0">

                            <div class="card-body p-1"></div>
                            <ul class="list-group" id="list">
                            </ul>
                        </div>
                    </div>
                </div>
                <div class="col-lg-12">
                    <div class="card">
                        <div style="max-height: 33vh;overflow: auto;" id="annotation-list" class="card-body p-1">
                            <h5 class="card-title m-2">Task List</h5>
                            <ul class="list-group" id="list">
                                {% for t in tasks %}
                                <li
                                    class="list-group-item text-nowrap text-sm overflow-auto {% if t.id == task.id  %}active{% endif %}">
                                    {% if t.approved %}
                                    <span class="badge bg-success"><i class="bi bi-check-circle-fill"></i>
                                        Approved</span>
                                    {% elif t.finished %}
                                    <span class="badge bg-success">Completed</span>
                                    {% elif t.label_by %}
                                    <span class="badge bg-warning">In Progress</span>
                                    {% else %}
                                    <span class="badge bg-secondary-light">Not Started</span>
                                    {% endif %}
                                    {% if t.id == task.id %}
                                    <p>{{t.path.split('/')[-1]}} </p>
                                    {% else %}
                                    <a href="{{url_for('main.project_task',id=t.id)}}">{{t.path.split('/')[-1] }} </a>
                                    {% endif %}

                                </li>
                                {% endfor %}
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>
</div>


<div class="card form-popup" id="popup">
    <div class="card-header">Annotation Editor</div>
    <div class="card-body">
        <label for="color-picker">Class </label>
        <select id="color-picker" name="color-picker" class="form-select form-select-sm mb-3">
            {% for label in project.labels_info['classname'] %}
            <option value="{{loop.index}}">{{label}}</option>
            {% endfor %}
        </select>
    </div>
    <div class="card-footer">
        <button class="btn btn-danger" id="annotation_class_cancle">Cancle</button>
        <button class="btn btn-success" id="annotation_class">Finish</button>
    </div>


</div>

<div class="pagetitle d-flex mt-auto justify-content-between align-content-center">
    <div class="pagetitle">
        <h1>Projects : {{project.name}}</h1>
        <nav>
            <ol class="breadcrumb">
                <li class="breadcrumb-item "><a href="{{url_for('main.home')}}">Projects</a></li>
                <li class="breadcrumb-item"><a href="{{url_for('main.project',id=project.id)}}">{{project.name}}</a>
                </li>
                <li class="breadcrumb-item active">{{task.path.split('/')[-1]}}</li>
            </ol>
        </nav>
    </div>
    <div>
        <a type="button" href="{{url_for('main.project_task',id=task.id-1)}}" id="prev-button"
            class="btn btn-primary {% if start %} disabled {% endif %}" data-bs-toggle="tooltip" data-bs-placement="top"
            title="[ : Previous task"><i class="bi bi-chevron-left"></i>Prev </a>
        <a type="button" href="{{url_for('main.project_task',id=task.id+1)}}" id="next-button"
            class="btn btn-primary {% if end %} disabled {% endif %}" data-bs-toggle="tooltip" data-bs-placement="top"
            title="] : Next task">Next<i class="bi bi-chevron-right"></i> </a>
        <button type="button" id="save-button" class="btn btn-primary " data-bs-toggle="tooltip" data-bs-placement="top"
            title="crl + s : Save"><i class="bx bxs-save"></i> Save</button>
        <button type="button" id="submit-button" class="btn btn-success" data-bs-toggle="tooltip"
            data-bs-placement="top" title="crl + enter : Submit"><i class="bx bxs-save"></i> Submit</button>
    </div>
</div>
{% endblock %}

{% block script %}
<!-- <script src="../static/scripts/drowing.js"></script> -->
<script>
    localStorage.setItem("colors", JSON.stringify([{% for color in project.labels_info['colors'] %}'{{color}}', {% endfor %}]));
    localStorage.setItem("classname", JSON.stringify([{% for color in project.labels_info['classname'] %}'{{color}}', {% endfor %}]));
    // Fetch boxes from the API
    function fetchBoxes() {
        fetch(`{{url_for('api.get_task',id=task.id)}}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                boxes = [...data]; // Assign fetched boxes to the boxes array
                firstBox = [...data]
                updateAnnotations();
                updateList();
            })
            .catch(error => {
                console.error('Failed fetching boxes:', error);
            });
    }
</script>
<script>
    document.addEventListener('DOMContentLoaded', function () {
        const image = document.getElementById('image');
        const container = document.getElementById('image-container');
        const img_container = document.getElementById('annotation-list')
        const annotationList = document.getElementById('list');
        const zoomInButton = document.getElementById('zoom-in');
        const zoomOutButton = document.getElementById('zoom-out');
        const zoomLevelSpan = document.getElementById('zoom-level');
        const deleteButton = document.getElementById('delete-button');
        const colorPicker = document.getElementById('color-picker');
        const saveButton = document.getElementById('save-button');
        const submitButton = document.getElementById('submit-button');
        const resetButton = document.getElementById('reset-button');
        const zoomControl = document.getElementById('zoom-control');
        let resizing = false;
        let currentHandle = null;
        let confirmed_box = false;
        let current_box, mode;

        const R_mode = document.getElementById('draw-mode');
        const E_mode = document.getElementById('edit-mode');

        const colors = JSON.parse(localStorage.getItem("colors"))
        const classesname = JSON.parse(localStorage.getItem("classname"))

        console.log("Colors", colors);

        let zoomLevel = 100;
        let drawing = false;
        let start_x = 0;
        let start_y = 0;
        let boxes = [];
        let firstBox = [];

        let undoStack = [];

        const verticalGuide = document.getElementById('vertical-guide');
        const horizontalGuide = document.getElementById('horizontal-guide');

        let dragging = false; // To know if a box is being dragged
        let draggedBox = null; // Reference to the box being dragged
        let offsetX = 0; // To store the initial X offset
        let offsetY = 0; // To store the initial Y offset

        saveButton.addEventListener('click', updateDatabase)
        submitButton.addEventListener('click', submitTask)

        // Guild line
        zoomControl.addEventListener('mousemove', function (event) {
            if (mode != 'draw') {
                verticalGuide.style.display = 'none';
                horizontalGuide.style.display = 'none';
                return;
            };
            const rect = zoomControl.getBoundingClientRect();
            const xPos = event.clientX - rect.left;
            const yPos = event.clientY - rect.top;

            verticalGuide.style.left = xPos + 'px';
            horizontalGuide.style.top = yPos + 'px';
            verticalGuide.style.display = 'block';
            horizontalGuide.style.display = 'block';
        });

        // hind Guild line
        zoomControl.addEventListener('mouseleave', function () {
            verticalGuide.style.display = 'none';
            horizontalGuide.style.display = 'none';
        });

        // Fetch boxes from the API
        function fetchBoxes() {
            fetch(`{{url_for('api.get_task',id=task.id)}}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    boxes = [...data]; // Assign fetched boxes to the boxes array
                    firstBox = [...data]
                    updateAnnotations();
                    updateList();
                })
                .catch(error => {
                    console.error('Failed fetching boxes:', error);
                });
        }

        fetchBoxes();

        function setMode(newMode) {
            mode = newMode;
            if (mode == 'draw') {
                R_mode.classList.add('disabled');
                E_mode.classList.remove('disabled');
                // console.log(document.getElementsByClassName('resize-handle'));
                let collect = document.getElementsByClassName('resize-handle')
                for (let i = 0; i < collect.length; i++) {
                    collect[i].style.display = 'none'
                }
            }
            if (mode == 'edit') {
                R_mode.classList.remove('disabled');
                E_mode.classList.add('disabled');
                let collect = document.getElementsByClassName('resize-handle')
                for (let i = 0; i < collect.length; i++) {
                    collect[i].style.display = 'block'
                }
            }
        }

        R_mode.addEventListener('click', function (e) { setMode('draw') });
        E_mode.addEventListener('click', function (e) { setMode('edit') });

        function openForm() {
            document.getElementById("popup").style.display = "block";
            document.getElementById("popup").style.left = event.clientX;
            document.getElementById("popup").style.top = event.clientY;
        }
        function cancleForm() {
            document.getElementById("popup").style.display = "none";
            let box = boxes.pop(-1);

            updateAnnotations();
            updateList();
        }
        function closeForm() {
            if (mode == 'edit') {
                document.getElementById("popup").style.display = "none";
                const selectedClass = colorPicker.value - 1;
                const classname = classesname[selectedClass]
                const borderColor = colors[selectedClass];

                const setOpacity = (hex, alpha) => `${hex}${Math.floor(alpha * 255).toString(16).padStart(2, 0)}`;
                const selectedAnnotations = document.querySelectorAll('.annotation.selected');
                const indicesToDelete = Array.from(selectedAnnotations).map(annotation => parseInt(annotation.dataset.index, 10));

                let box = boxes[indicesToDelete.splice(-1)]
                box['classname'] = selectedClass;
                box['borderColor'] = borderColor;
                box['backgroundColor'] = borderColor + '00';
                console.log(box);
                // boxes.push(box);

                updateAnnotations();
                updateList();
            } else {
                document.getElementById("popup").style.display = "none";
                const selectedClass = colorPicker.value - 1;
                const classname = classesname[selectedClass]
                const borderColor = colors[selectedClass];
                const setOpacity = (hex, alpha) => `${hex}${Math.floor(alpha * 255).toString(16).padStart(2, 0)}`;
                let box = boxes.pop(-1);
                // if (mode === 'edit') {
                //     const selectedAnnotations = document.querySelectorAll('.annotation.selected');
                //     const indicesToDelete = Array.from(selectedAnnotations).map(annotation => parseInt(annotation.dataset.index, 10));
                //     console.log(indicesToDelete);
                //     // box = boxes[indicesToDelete.slice(-1)]
                //     let box = boxes.pop(indicesToDelete.slice(0));
                // } else {
                //     let box = boxes.pop(-1);
                // }



                box['classname'] = selectedClass;
                box['borderColor'] = borderColor;
                box['backgroundColor'] = borderColor + '00';
                console.log(box);
                boxes.push(box);

                updateAnnotations();
                updateList();
            }

        }
        document.getElementById("annotation_class_cancle").addEventListener('click', cancleForm)
        document.getElementById("annotation_class").addEventListener('click', closeForm)

        function arraysHaveSameContent(arr1, arr2) {
            if (arr1.length !== arr2.length) return false;
            return arr1.slice().sort().every((value, index) => value === arr2.slice().sort()[index]);
        }

        // Save
        async function updateDatabase() {
            res = await fetch(`{{url_for('api.update_task',id=task.id)}}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ "label": boxes })
            })

            firstBox = [...boxes]
            updateList()
            console.log({
                "label": boxes
            })
        }

        // Submit
        async function submitTask() {
            res = await fetch(`{{url_for('api.update_task',id=task.id)}}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ "label": boxes, "finished": true }),
            })
            firstBox = [...boxes]
            console.log({
                "label": boxes, "finished": true
            })
            window.location.reload();
        }

        function updateAnnotations() {
            const existingAnnotations = document.querySelectorAll('.annotation');
            existingAnnotations.forEach((annotation) => {
                annotation.remove();
            });

            boxes.forEach((box, index) => createAnnotation(box, index));
        }

        function updateList() {
            if (arraysHaveSameContent(boxes, firstBox)) {
                saveButton.classList.add('disabled');
                // console.log(saveButton.classList)
                console.log('disabled')
                console.log(`box`);
                console.log(boxes);
                console.log(`firstBox`);
                console.log(firstBox);
            } else {
                saveButton.classList.remove('disabled');
                console.log('show')
                console.log(`box`);
                console.log(boxes);
                console.log(`firstBox`);
                console.log(firstBox);
            }
            annotationList.innerHTML = '';
            boxes.forEach((box, index) => {
                const listItem = document.createElement('li');
                listItem.dataset.index = index
                listItem.style.backgroundColor = box.backgroundColor
                listItem.classList.add('list-group-item');
                const tmp = `<input class="form-check-input me-1" type="checkbox" value="1" aria-label="..." disabled ><span class="badge pill bg-secondary-light" style="background-color:${colors[box.classname]}">id ${index}:  ${classesname[box.classname]}</span>`;
                listItem.innerHTML = tmp
                if (box.approved) {
                    const tmp = `<input class="form-check-input me-1" type="checkbox" id="check${index}" data-index="${index}" value="${index}" aria-label="..." checked disabled>
                <span class="badge pill bg-secondary-light" style="background-color:${colors[box.classname]}"> ${classesname[box.classname]}</span>
                <div class="text-dark">${box.commnet}</div>`;
                    listItem.innerHTML = tmp
                }
                else {
                    const tmp = `<input class="form-check-input me-1" type="checkbox" id="check${index}" data-index="${index}" value="${index}" aria-label="..." disabled>
                <span class="badge pill bg-secondary-light" style="background-color:${colors[box.classname]}">  ${classesname[box.classname]}</span>
                <div class="text-dark">${box.commnet}</div>`;
                    listItem.innerHTML = tmp
                }
                // listItem.textContent = `${classesname[box.classname]}: x=${(box.x).toFixed(2)}, y=${(box.y).toFixed(2)}, width=${(box.width).toFixed(2)}, height=${box.height.toFixed(2)}, class=${box.classname}`;

                listItem.addEventListener('click', function (e) {
                    const anno = document.querySelector(`div.annotation[data-index="${index}"]`);
                    anno.classList.toggle('selected');
                    if ([...anno.classList].includes('selected')) {
                        openForm();
                    } else {
                        closeForm();
                    }
                })
                listItem.addEventListener('mouseover', function (e) {
                    const anno = document.querySelector(`div.annotation[data-index="${index}"]`);
                    anno.style.backgroundColor = box.borderColor + '44'
                    listItem.style.backgroundColor = box.borderColor + '44'

                })
                listItem.addEventListener('mouseout', function (e) {
                    const anno = document.querySelector(`div.annotation[data-index="${index}"]`);
                    anno.style.backgroundColor = box.borderColor + '00'
                    listItem.style.backgroundColor = box.borderColor + '00'
                })
                annotationList.appendChild(listItem);
            });
        }

        function adjustZoom(factor) {
            zoomLevel += factor;
            zoomLevel = Math.min(Math.max(zoomLevel, 20), 200);
            image.style.width = `${zoomLevel}vw`;
            // zoomLevelSpan.textContent = zoomLevel;

            // Original dimensions
            const originalWidth = image.naturalWidth;
            const originalHeight = image.naturalHeight;

            // Displayed dimensions
            const displayedWidth = image.width;
            const displayedHeight = image.height;

            console.log(`Original dimensions: ${originalWidth}x${originalHeight}`);
            console.log(`Displayed dimensions: ${displayedWidth}x${displayedHeight}`);
            updateAnnotations();
            updateList();
        }

        // Create Box
        function createAnnotation(box, index) {
            const annotation = document.createElement('div');
            annotation.className = 'annotation';
            annotation.dataset.index = index;

            annotation.style.borderColor = box.borderColor;
            annotation.style.backgroundColor = box.backgroundColor
            // if (box.approved) {
            //     annotation.innerHTML = `<span style="background-color: ${box.borderColor}; color: #fff">id = ${index + 1} : ${classesname[box.classname]} <i class="bi bi-check-circle-fill"></i> </span>`
            // } else {
            //     annotation.innerHTML = `<span style="background-color: ${box.borderColor}; color: #fff">id = ${index + 1} : ${classesname[box.classname]} `
            // }
            annotation.addEventListener('mousedown', function () {
                if (mode == 'edit') {
                    dragging = false;
                    annotation.classList.toggle('selected');
                }
            });
            annotation.addEventListener('mouseover', function () {
                if (mode == 'edit') {
                    annotation.style.backgroundColor = box.borderColor + '33';
                    dragging = false;
                    console.log(index);
                    annotation.style.zIndex = 999

                    const li = document.querySelector(`li[data-index="${index}"]`);
                    li.style.backgroundColor = box.borderColor + '33';
                }

            });
            annotation.addEventListener('mouseout', function () {
                if (mode == 'edit') {
                    const li = document.querySelector(`li[data-index="${index}"]`);
                    li.style.backgroundColor = box.borderColor + '00';
                }

            });

            annotation.addEventListener('click', function () {
                if (mode == 'edit') {
                    dragging = false;
                    annotation.classList.toggle('selected');
                    if ([...annotation.classList].includes('selected')) {
                        openForm();
                    } else {
                        closeForm();
                    }
                }
            });


            annotation.style.left = `${box.x * image.width}px`;
            annotation.style.top = `${box.y * image.height}px`;
            annotation.style.width = `${box.width * image.width}px`;
            annotation.style.height = `${box.height * image.height}px`;

            ['nw', 'ne', 'sw', 'se', 'm'].forEach(pos => {
                const handle = document.createElement('div');
                handle.className = `resize-handle ${pos}`;
                if (mode === 'draw') {
                    handle.style.display = 'none';
                }
                handle.style.position = 'absolute';
                if (pos.includes('n')) handle.style.top = '-4px';
                if (pos.includes('s')) handle.style.bottom = '-4px';
                if (pos.includes('w')) handle.style.left = '-4px';
                if (pos.includes('e')) handle.style.right = '-4px';
                handle.style.width = '8px';
                handle.style.height = '8px';
                handle.style.backgroundColor = box.borderColor;
                if (pos === 'm') {
                    handle.style.top = '0px';
                    handle.style.left = '0px';
                    handle.style.width = '100%';
                    handle.style.height = '100%';
                    handle.style.backgroundColor = box.backgroundColor
                    // handle.style.transform = 'translate(-50%, -50%)';
                    handle.style.borderRadius = '10%';
                    handle.addEventListener('click', function () {
                        if (mode == 'edit') {
                            dragging = false;
                            annotation.classList.toggle('selected');
                            if ([...annotation.classList].includes('selected')) {
                                openForm();
                            } else {
                                closeForm();
                            }
                        }
                    })
                }
                annotation.appendChild(handle);
            });

            container.appendChild(annotation);
        }

        zoomControl.addEventListener('mousedown', function (event) {
            if (mode === 'edit') {
                dragging = true;
                isDragging = true;
                const rect = image.getBoundingClientRect();
                dragStartX = event.clientX - rect.left;
                dragStartY = event.clientY - rect.top;

                updateAnnotations()
            }

        });
        zoomControl.addEventListener('mousemove', function (event) {
            if (dragging) {
                const rect = image.getBoundingClientRect();
                const end_x = (event.clientX - rect.left);
                const end_y = (event.clientY - rect.top);

                const dx = end_x - dragStartX;
                const dy = end_y - dragStartY;
                const tempw = container.style.width
                const temph = container.style.height

                // image.style.position = "";
                console.log(dx, dy, container.style.left, parseInt(container.style.top));
                let valuex = parseInt(container.style.left) + dx
                let valuey = parseInt(container.style.top) + dy
                console.log(dx, dy, container.style.left, container.style.top, valuex, valuey);
                container.style.left = (parseInt(container.style.left) + dx) + "px";
                container.style.top = (parseInt(container.style.top) + dy) + "px";
                container.style.width = tempw
                container.style.height = temph
                updateAnnotations()
            }

        });
        zoomControl.addEventListener('mouseout', function (event) {
            dragging = false;
            updateAnnotations()
        })
        zoomControl.addEventListener('mouseup', function (event) {
            dragging = false;
            updateAnnotations()
        })

        container.addEventListener('mouseover', function (event) {
            console.log('over');
            if (mode === 'draw') {
                this.style.cursor = 'default';
            } else if (mode === 'edit') {
                this.style.cursor = 'pointer';
            }
        });
        container.addEventListener('mousedown', function (event) {
            if (mode === 'draw') {
                drawing = true;
                const rect = image.getBoundingClientRect();
                start_x = (event.clientX - rect.left);
                start_y = (event.clientY - rect.top);
                console.log(`x=${start_x} , y=${start_y}`);
            }
        });

        container.addEventListener('mousemove', function (event) {
            console.log(dragging);
            if (drawing) {
                const rect = image.getBoundingClientRect();
                const end_x = (event.clientX - rect.left);
                const end_y = (event.clientY - rect.top);

                const selectedClass = colorPicker.value - 1;
                const classname = classesname[selectedClass]
                const borderColor = colors[selectedClass];
                const setOpacity = (hex, alpha) => `${hex}${Math.floor(alpha * 255).toString(16).padStart(2, 0)}`;

                const box = {
                    x: Math.min(start_x, end_x) / image.width,
                    y: Math.min(start_y, end_y) / image.height,
                    width: Math.abs(end_x - start_x) / image.width,
                    height: Math.abs(end_y - start_y) / image.height,
                    classname: selectedClass,
                    borderColor: borderColor,
                    backgroundColor: borderColor + '00',
                    approved: false,
                    commnet: ''
                };
                if (box.height == 0 || box.width == 0) return;

                console.log(box.width, box.height);

                updateAnnotations();
                updateList();
                createAnnotation(box)
            };

        });
        container.addEventListener('mouseout', function (event) {
            console.log('out');
            // if (drawing) {
            //     const rect = image.getBoundingClientRect();
            //     const end_x = (event.clientX - rect.left );
            //     const end_y = (event.clientY - rect.top);

            //     const selectedClass = colorPicker.value - 1;
            //     const classname = classesname[selectedClass]
            //     const borderColor = colors[selectedClass];
            //     const setOpacity = (hex, alpha) => `${hex}${Math.floor(alpha * 255).toString(16).padStart(2, 0)}`;

            //     const box = {
            //         x: Math.min(start_x, end_x) / image.width,
            //         y: Math.min(start_y, end_y) / image.height,
            //         width: Math.abs(end_x - start_x) / image.width,
            //         height: Math.abs(end_y - start_y) / image.height,
            //         classname: selectedClass,
            //         borderColor: borderColor,
            //         backgroundColor: borderColor + '00',
            //         approved: false,
            //         commnet: ''
            //     };
            //     if (box.height == 0 || box.width == 0) return;
            //     openForm()



            //     boxes.push(box);

            //     updateAnnotations();
            //     updateList();
            //     drawing = false
            //     };
        });

        container.addEventListener('mouseup', function (event) {
            if (drawing) {
                drawing = false;
                const rect = image.getBoundingClientRect();
                const end_x = (event.clientX - rect.left);
                const end_y = (event.clientY - rect.top);


                const selectedClass = colorPicker.value - 1;
                const classname = classesname[selectedClass]
                const borderColor = colors[selectedClass];
                const setOpacity = (hex, alpha) => `${hex}${Math.floor(alpha * 255).toString(16).padStart(2, 0)}`;



                const box = {
                    x: Math.min(start_x, end_x) / image.width,
                    y: Math.min(start_y, end_y) / image.height,
                    width: Math.abs(end_x - start_x) / image.width,
                    height: Math.abs(end_y - start_y) / image.height,
                    classname: selectedClass,
                    borderColor: borderColor,
                    backgroundColor: borderColor + '00',
                    approved: false,
                    commnet: ''
                };
                if (box.height == 0 || box.width == 0) return;
                openForm()



                boxes.push(box);

                updateAnnotations();
                updateList();
                // createAnnotation(box);
            }
            if (dragging) {
                dragging = false;
            }
        });

        zoomInButton.addEventListener('click', function () {
            adjustZoom(10);
        });

        zoomOutButton.addEventListener('click', function () {
            adjustZoom(-10);
        });

        deleteButton.addEventListener('click', function () {
            // Collect all the selected annotations
            const selectedAnnotations = document.querySelectorAll('.annotation.selected');

            // Get their indices
            const indicesToDelete = Array.from(selectedAnnotations).map(annotation => parseInt(annotation.dataset.index, 10));

            // Remove the annotation element from the DOM
            selectedAnnotations.forEach(annotation => {
                annotation.remove();
            });

            // Remove the corresponding boxes
            boxes = boxes.filter((box, index) => !indicesToDelete.includes(index));

            // Update indices and re-render all remaining annotations
            updateAnnotations();
            updateList();
        });

        resetButton.addEventListener('click', function () {
            boxes = []
            updateAnnotations();
            updateList();
        })

        document.addEventListener('mouseup', function () {
            resizing = false;
            currentHandle = null;
        });

        zoomControl.addEventListener('wheel', function (event) {
            if (event.ctrlKey) {
                adjustZoom(event.deltaY < 0 ? 5 : -5);
                event.preventDefault();
            }
        });

        // Start Move box 
        container.addEventListener('mousedown', function (event) {
            const handle = event.target.closest('.resize-handle');
            if (handle) {
                resizing = true;
                currentHandle = handle;
                // console.log(currentHandle);
                const rect = image.getBoundingClientRect();
                start_x = (event.clientX - rect.left) / image.width;
                start_y = (event.clientY - rect.top) / image.height;
            }
        });

        // Move box
        container.addEventListener('mousemove', function (event) {
            if (!resizing || !currentHandle) return;
            const rect = image.getBoundingClientRect();
            const x = (event.clientX - rect.left) / image.width;
            const y = (event.clientY - rect.top) / image.height;
            const box = boxes[parseInt(currentHandle.parentElement.dataset.index)];
            const canses = currentHandle.className.split(' ')[1]

            switch (canses) {
                case 'nw':
                    box.width += (box.x - x);
                    box.height += (box.y - y);
                    box.x = x;
                    box.y = y;
                    break;
                case 'ne':
                    box.width = x - box.x;
                    box.height += box.y - y;
                    box.y = y;
                    break;
                case 'sw':
                    box.width += box.x - x;
                    box.height = y - box.y;
                    box.x = x;
                    break;
                case 'se':
                    box.width = x - box.x;
                    box.height = y - box.y;
                    break;
                case 'm':
                    // const deltaX = (x - (box.x + box.width / 2));
                    // const deltaY = (y - (box.y + box.height / 2));
                    // box.x += deltaX;
                    // box.y += deltaY;
                    box.x += x - start_x;
                    box.y += y - start_y;
                    start_x = x
                    start_y = y

            }
            if (box.x < 0) {
                box.x = 0
            }
            if (box.y < 0) {
                box.y = 0
            }
            if (box.x + box.width > 1) {
                // console.log(box.x , box.width);
                box.x = 1 - box.width
                // box.width = 1 - box.x
                // return
            }
            if (box.y + box.height > 1) {
                // box.height = 1 - box.y
                box.y = 1 - box.height
                // return
            }


            updateAnnotations();
            updateList();
        });

        // Listen for keyboard shortcuts for undo (Ctrl+Z) and redo (Ctrl+Shift+Z)
        document.addEventListener('keydown', function (event) {
            if (!isNaN(event.key) && event.key >= 1 && event.key <= colorPicker.options.length) {
                colorPicker.value = event.key;

                // Trigger the change event if there's an event listener for it
                const changeEvent = new Event('change');
                colorPicker.dispatchEvent(changeEvent);
            }

            // Check if Ctrl+Enter is pressed
            if (event.ctrlKey && event.key === 'Enter') {
                // Call the desired function or action here
                submitTask()

            }

            if (event.key === 'Backspace') {
                // Perform deletion here
                const selectedAnnotations = document.querySelectorAll('.annotation.selected');

                // Get their indices
                const indicesToDelete = Array.from(selectedAnnotations).map(annotation => parseInt(annotation.dataset.index, 10));

                // Remove the annotation element from the DOM
                selectedAnnotations.forEach(annotation => {
                    annotation.remove();
                });

                // Remove the corresponding boxes
                boxes = boxes.filter((box, index) => !indicesToDelete.includes(index));

                // Update indices and re-render all remaining annotations
                updateAnnotations();
                updateList();
            }

            if (event.key === 'r') {
                setMode('draw')
            }
            if (event.key === 'e') {
                setMode('edit')
            }
            {% if start %}
            {% else %}
            if (event.key === '[') {
                // setMode('draw')
                document.getElementById("prev-button").click();

            }
            {% endif %}
            {% if end %}
            {% else %}
            if (event.key === ']') {
                // setMode('draw')
                document.getElementById("next-button").click();
            }

            {% endif %}
            if (event.ctrlKey && event.key === 's') {
                // console.log('save');
                updateDatabase()
            }
            if (event.ctrlKey && event.key === 'enter') {
                // console.log('save');
                submitTask()
                {% if end %}
                {% else %}
                if (event.key === ']') {
                    // setMode('draw')
                    document.getElementById("next-button").click();
                }

                {% endif %}

            }
            // Check if Ctrl+Z is pressed
            if (event.ctrlKey && event.key === 'z') {

                if (boxes.length > 0) {
                    // Pop the last box and store it in the undo stack
                    const lastBox = boxes.pop();
                    undoStack.push(lastBox);

                    // Update annotations and list
                    updateAnnotations();
                    updateList();
                }
            }
            // Implement Ctrl+Shift+Z for redo
            else if (event.ctrlKey && event.shiftKey && event.key === 'Z') {
                if (undoStack.length > 0) {
                    // Pop the last undone box and put it back in boxes
                    const lastUndoneBox = undoStack.pop();
                    boxes.push(lastUndoneBox);

                    // Update annotations and list
                    updateAnnotations();
                    updateList();
                }
            }
        });
        
        container.style.left = 0 + 'px'
        container.style.top = 0 + 'px'
        // fun
        setMode('draw')
    });

</script>
{% endblock %}