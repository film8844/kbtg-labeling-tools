{% extends "base.html" %}
{% block css %}
<style>
    #vertical-guide,
    #horizontal-guide {
        position: absolute;
        background-color: gray;
        pointer-events: none;
        /* ensures the guidelines don't interfere with other mouse events */
        display: none;
        /* hide them by default */
        z-index: 10;
        /* position them above other elements, adjust as needed */
    }

    #vertical-guide {
        width: 1px;
        height: 100%;

        top: 0;
    }

    #horizontal-guide {
        height: 1px;
        width: 100%;

        left: 0;
    }


    #image-container {
        position: relative;
        height: 100%;

        background-color: #fff;
    }

    #image-container {
        position: relative;
        height: 100%;
        background-color: #fff;
    }

    #image-container :hover {
        cursor: crosshair;
    }

    #zoom-controls {
        height: 100%;
        /* overflow: auto; */
    }



    #image :hover {
        cursor: crosshair;
    }

    .annotation {
        position: absolute;
        border: 2px solid red;
        background-color: rgba(255, 0, 0, 0.2);
        z-index: 2;
    }

    .annotation :hover {
        cursor: pointer !important;
    }

    .annotation.selected {
        border: 2px dashed gray;
    }

    select option[selected] {
        background-color: '#fff'
    }

    .resize-handle {
        cursor: pointer;
        z-index: 2;
    }
</style>
{% endblock %}

{% block content %}
<div class="pagetitle d-flex justify-content-between align-content-center">
    <div class="pagetitle">
        <h1>Projects : {{project.name}}</h1>
        <nav>
            <ol class="breadcrumb">
                <li class="breadcrumb-item "><a href="{{url_for('main.home')}}">Projects</a></li>
                <li class="breadcrumb-item"><a href="{{url_for('main.project',id=project.id)}}">{{project.name}}</a>
                </li>
                <li class="breadcrumb-item active">{{task.path}}</li>
            </ol>
        </nav>
    </div><!-- End Page Title -->
    <div>


        <a type="button" href="{{url_for('main.project_task',id=task.id-1)}}" id="prev-button"
            class="btn btn-primary {% if start %} disabled {% endif %}"><i class="bi bi-chevron-left"></i>Prev </a>
        <a type="button" href="{{url_for('main.project_task',id=task.id+1)}}" id="next-button"
            class="btn btn-primary {% if end %} disabled {% endif %}">Next<i class="bi bi-chevron-right"></i> </a>
        <button type="button" id="save-button" class="btn btn-primary "><i class="bx bxs-save"></i> Save</button>
        <button type="button" id="submit-button" class="btn btn-success"><i class="bx bxs-save"></i> Submit</button>
    </div>
</div>

<section class=" section">
    {% with messages = get_flashed_messages(with_categories=true) %}
    {% if messages %}
    {% for category, message in messages %}
    {% if category %}
    <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert">
        {{ message }}
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>

    {% endif %}
    {% endfor %}
    {% endif %}
    {% endwith %}
    <div class="row">
        
        <div class="col-10">
            <div id="image-container">
                <div id="vertical-guide"></div>
                <div id="horizontal-guide"></div>
                <div id="zoom-controls">
                    <div id="annotation-list"></div>
                    <img id="image" draggable="false" src="../{{task.path}}" alt="Image for annotation">
                </div>
            </div>
        </div>
        <div class="col-2 mt-3">
            <div class="col-lg-12">

                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">Label</h5>
                        <select id="color-picker" class="form-select form-select-lg mb-3">
                            {% for label in project.labels_info['classname'] %}
                            <option value="{{loop.index}}">{{label}}</option>
                            {% endfor %}
                        </select>
                        <h5 class="card-title">Zoom Level: <span id="zoom-level">100</span>%</h5>
                        <div id="zoom-controls" class="mb-2">
                            <button id="zoom-in" class="btn btn-primary"><i class="bi bi-zoom-in"></i></button>
                            <button id="zoom-out" class="btn btn-primary"><i class="bi bi-zoom-out"></i></button>

                        </div>
                        <button id="delete-button" class="btn btn-danger mb-2">Delete</button>
                        <button id="reset-button" class="btn btn-danger mb-2">Reset</button>
                    </div>
                </div>

            </div>
            <div class="col-lg-12">

                <div class="card ">
                    <div style="height: 30vh;overflow: auto;" id="annotation-list" class="card-body ">
                        <h5 class="card-title">Annotation List</h5>
                        <ul class="list-group" id="list">
                        </ul>
                    </div>
                </div>

            </div>
            
        </div>
        <span></span>
    </div>
    <!-- Gallery -->



    <!-- Gallery -->




</section>
<!-- End Vertically centered Modal -->
<div class="modal fade" id="delete-model" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Delete Project</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <form>
                <div class="modal-body">
                    Fill the confirm text
                    <input class="form-control" type="text">
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="submit" class="btn btn-danger">Delete</button>
                </div>
            </form>
        </div>
    </div>
</div><!-- End Basic Modal-->
<!-- End Vertically centered Modal  -->
{% endblock %}

{% block script %}
<!-- <script src="../static/scripts/drowing.js"></script> -->
<script>
    document.addEventListener('DOMContentLoaded', function () {
        const image = document.getElementById('image');
        const container = document.getElementById('image-container');
        const img_container = document.getElementById('annotation-list')
        const annotationList = document.getElementById('list');
        const zoomInButton = document.getElementById('zoom-in');
        const zoomOutButton = document.getElementById('zoom-out');
        const zoomLevelSpan = document.getElementById('zoom-level');
        const deleteButton = document.getElementById('delete-button');
        const colorPicker = document.getElementById('color-picker');
        const saveButton = document.getElementById('save-button');
        const submitButton = document.getElementById('submit-button');
        const resetButton = document.getElementById('reset-button');
        let resizing = false;
        let currentHandle = null;
        const colors = [{% for color in project.labels_info['colors'] %}'{{color}}', {% endfor %}]
        const classesname = [{% for color in project.labels_info['classname'] %}'{{color}}', {% endfor %}]

    let zoomLevel = 100;
    let drawing = false;
    let start_x = 0;
    let start_y = 0;
    let boxes = [];
    let firstBox = [];

    let undoStack = [];

    const verticalGuide = document.getElementById('vertical-guide');
    const horizontalGuide = document.getElementById('horizontal-guide');

    let dragging = false; // To know if a box is being dragged
    let draggedBox = null; // Reference to the box being dragged
    let offsetX = 0; // To store the initial X offset
    let offsetY = 0; // To store the initial Y offset


    container.addEventListener('mousemove', function (event) {
        const rect = container.getBoundingClientRect();
        const xPos = event.clientX - rect.left;
        const yPos = event.clientY - rect.top;

        verticalGuide.style.left = xPos + 'px';
        horizontalGuide.style.top = yPos + 'px';
        verticalGuide.style.display = 'block';
        horizontalGuide.style.display = 'block';
    });

    container.addEventListener('mousemove', function (event) {
        if (!dragging || !draggedBox) return;

        const containerRect = container.getBoundingClientRect();
        const newX = (event.clientX - containerRect.left) - offsetX;
        const newY = (event.clientY - containerRect.top) - offsetY;

        draggedBox.x = newX / image.width;
        draggedBox.y = newY / image.height;

        updateAnnotations();
    });

    container.addEventListener('mouseleave', function () {
        verticalGuide.style.display = 'none';
        horizontalGuide.style.display = 'none';
    });




    saveButton.addEventListener('click', updateDatabase)
    submitButton.addEventListener('click', submitTask)

    // Fetch boxes from the API
    function fetchBoxes() {
        fetch(`{{url_for('api.get_task',id=task.id)}}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                boxes = [...data]; // Assign fetched boxes to the boxes array
                firstBox = [...data]
                updateAnnotations();
                updateList();

            })
            .catch(error => {
                console.error('Failed fetching boxes:', error);
            });

    }

    // Assuming you have the imageId somewhere, you can call this function
    fetchBoxes();

    async function updateDatabase() {
        res = await fetch(`{{url_for('api.update_task',id=task.id)}}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ "label": boxes, "label_by": {{ current_user.id }}})
            })

    firstBox = [...boxes]
    updateList()
    console.log({ "label": boxes, "label_by": {{ current_user.id }}})
    }

    async function submitTask() {
        res = await fetch(`{{url_for('api.update_task',id=task.id)}}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ "label": boxes, "label_by": {{ current_user.id }}, "finished": true}),
        })
    firstBox = [...boxes]
    console.log({ "label": boxes, "label_by": {{ current_user.id }}, "finished": true})
    }

    function updateAnnotations() {

        const existingAnnotations = document.querySelectorAll('.annotation');
        existingAnnotations.forEach((annotation) => {
            annotation.remove();
        });

        boxes.forEach((box, index) => createAnnotation(box, index));
    }

    function arraysHaveSameContent(arr1, arr2) {
        if (arr1.length !== arr2.length) return false;
        return arr1.slice().sort().every((value, index) => value === arr2.slice().sort()[index]);
    }
    function updateList() {
        if (arraysHaveSameContent(boxes, firstBox)) {
            saveButton.classList.add('disabled');
            // console.log(saveButton.classList)
            console.log('disabled')
            console.log(`box`);
            console.log(boxes);
            console.log(`firstBox`);
            console.log(firstBox);
        } else {
            saveButton.classList.remove('disabled');
            console.log('show')
            console.log(`box`);
            console.log(boxes);
            console.log(`firstBox`);
            console.log(firstBox);
        }
        annotationList.innerHTML = '';
        boxes.forEach((box, index) => {
            const listItem = document.createElement('li');
            listItem.style.backgroundColor = box.backgroundColor
            listItem.classList.add('list-group-item');
            const tmp = `<input class="form-check-input me-1" type="checkbox" value="1" aria-label="..." disabled ><span class="badge pill bg-secondary-light" style="background-color:${colors[box.classname]}">id ${index}:  ${classesname[box.classname]}</span>`;
            listItem.innerHTML = tmp
            if (box.approved) {
                const tmp = `<input class="form-check-input me-1" type="checkbox" id="check${index}" data-index="${index}" value="${index}" aria-label="..." checked disabled>
                <span class="badge pill bg-secondary-light" style="background-color:${colors[box.classname]}">id ${index}:  ${classesname[box.classname]}</span>
                <div class="text-dark">${box.commnet}</div>`;
                listItem.innerHTML = tmp
            }
            else {
                const tmp = `<input class="form-check-input me-1" type="checkbox" id="check${index}" data-index="${index}" value="${index}" aria-label="..." disabled>
                <span class="badge pill bg-secondary-light" style="background-color:${colors[box.classname]}">id ${index}:  ${classesname[box.classname]}</span>
                <div class="text-dark">${box.commnet}</div>`;
                listItem.innerHTML = tmp
            }
            // listItem.textContent = `${classesname[box.classname]}: x=${(box.x).toFixed(2)}, y=${(box.y).toFixed(2)}, width=${(box.width).toFixed(2)}, height=${box.height.toFixed(2)}, class=${box.classname}`;
            annotationList.appendChild(listItem);
        });
    }

    function adjustZoom(factor) {
        zoomLevel += factor;
        zoomLevel = Math.min(Math.max(zoomLevel, 50), 200);
        image.style.width = `${zoomLevel}%`;
        zoomLevelSpan.textContent = zoomLevel;

        // Original dimensions
        const originalWidth = image.naturalWidth;
        const originalHeight = image.naturalHeight;

        // Displayed dimensions
        const displayedWidth = image.width;
        const displayedHeight = image.height;

        console.log(`Original dimensions: ${originalWidth}x${originalHeight}`);
        console.log(`Displayed dimensions: ${displayedWidth}x${displayedHeight}`);
        updateAnnotations();
    }

    function createAnnotation(box, index) {
        const annotation = document.createElement('div');
        annotation.className = 'annotation';
        annotation.dataset.index = index;
        
        annotation.style.borderColor = box.borderColor;
        annotation.style.backgroundColor = box.backgroundColor
        if (box.approved){
        annotation.innerHTML = `<span style="background-color: ${box.borderColor}; color: #fff">id = ${index + 1} : ${classesname[box.classname]} <i class="bi bi-check-circle-fill"></i> </span>`
        } else {
        annotation.innerHTML = `<span style="background-color: ${box.borderColor}; color: #fff">id = ${index + 1} : ${classesname[box.classname]} `

        }
            
        annotation.addEventListener('click', function () {
            annotation.classList.toggle('selected');
        });


        annotation.style.left = `${box.x * image.width}px`;
        annotation.style.top = `${box.y * image.height}px`;
        annotation.style.width = `${box.width * image.width}px`;
        annotation.style.height = `${box.height * image.height}px`;

        ['nw', 'ne', 'sw', 'se', 'm'].forEach(pos => {
            const handle = document.createElement('div');
            handle.className = `resize-handle ${pos}`;
            handle.style.position = 'absolute';
            if (pos.includes('n')) handle.style.top = '-4px';
            if (pos.includes('s')) handle.style.bottom = '-4px';
            if (pos.includes('w')) handle.style.left = '-4px';
            if (pos.includes('e')) handle.style.right = '-4px';
            handle.style.width = '8px';
            handle.style.height = '8px';
            handle.style.backgroundColor = box.borderColor;
            if (pos === 'm') {
                handle.style.top = '50%';
                handle.style.left = '50%';
                handle.style.width = '16px';
                handle.style.height = '16px';
                handle.style.transform = 'translate(-50%, -50%)';
                handle.style.borderRadius = '50%';
            }

            annotation.appendChild(handle);
        });

        container.appendChild(annotation);
    }

    image.addEventListener('mousedown', function (event) {
        drawing = true;
        const rect = image.getBoundingClientRect();
        start_x = (event.clientX - rect.left);
        start_y = (event.clientY - rect.top);
        console.log(`x=${start_x} , y=${start_y}`);
    });

    image.addEventListener('mouseup', function (event) {
        if (!drawing) return;
        drawing = false;

        const rect = image.getBoundingClientRect();
        const end_x = (event.clientX - rect.left);
        const end_y = (event.clientY - rect.top);


        const selectedClass = colorPicker.value - 1;
        const classname = classesname[selectedClass]
        const borderColor = colors[selectedClass];
        const setOpacity = (hex, alpha) => `${hex}${Math.floor(alpha * 255).toString(16).padStart(2, 0)}`;


        const box = {
            x: Math.min(start_x, end_x) / image.width,
            y: Math.min(start_y, end_y) / image.height,
            width: Math.abs(end_x - start_x) / image.width,
            height: Math.abs(end_y - start_y) / image.height,
            classname: selectedClass,
            borderColor: borderColor,
            backgroundColor: borderColor + '40',
            approved: false,
            commnet:''
        };
        if (box.height == 0 || box.width == 0) return;


        boxes.push(box);

        updateAnnotations();
        updateList();
    });

    zoomInButton.addEventListener('click', function () {
        adjustZoom(10);
    });

    zoomOutButton.addEventListener('click', function () {
        adjustZoom(-10);
    });


    deleteButton.addEventListener('click', function () {
        // Collect all the selected annotations
        const selectedAnnotations = document.querySelectorAll('.annotation.selected');

        // Get their indices
        const indicesToDelete = Array.from(selectedAnnotations).map(annotation => parseInt(annotation.dataset.index, 10));

        // Remove the annotation element from the DOM
        selectedAnnotations.forEach(annotation => {
            annotation.remove();
        });

        // Remove the corresponding boxes
        boxes = boxes.filter((box, index) => !indicesToDelete.includes(index));

        // Update indices and re-render all remaining annotations
        updateAnnotations();
        updateList();
    });

    resetButton.addEventListener('click', function () {
        boxes = []
        updateAnnotations();
        updateList();
    })

    container.addEventListener('mousedown', function (event) {
        const handle = event.target.closest('.resize-handle');
        if (handle) {
            resizing = true;
            currentHandle = handle;
            console.log(currentHandle);
        }
    });

    document.addEventListener('mouseup', function () {
        resizing = false;
        currentHandle = null;
    });

    container.addEventListener('mousemove', function (event) {
        if (!resizing || !currentHandle) return;
        const rect = image.getBoundingClientRect();
        const x = (event.clientX - rect.left) / image.width;
        const y = (event.clientY - rect.top) / image.height;
        const box = boxes[parseInt(currentHandle.parentElement.dataset.index)];
        const canses = currentHandle.className.split(' ')[1]

        switch (canses) {
            case 'nw':
                box.width += (box.x - x);
                box.height += (box.y - y);
                box.x = x;
                box.y = y;
                break;
            case 'ne':
                box.width = x - box.x;
                box.height += box.y - y;
                box.y = y;
                break;
            case 'sw':
                box.width += box.x - x;
                box.height = y - box.y;
                box.x = x;
                break;
            case 'se':
                box.width = x - box.x;
                box.height = y - box.y;
                break;
            case 'm':
                const deltaX = (x - (box.x + box.width / 2));
                const deltaY = (y - (box.y + box.height / 2));
                box.x += deltaX;
                box.y += deltaY;
        }

        updateAnnotations();
        updateList();
    });

    // Listen for keyboard shortcuts for undo (Ctrl+Z) and redo (Ctrl+Shift+Z)
    document.addEventListener('keydown', function (event) {

        if (!isNaN(event.key) && event.key >= 1 && event.key <= colorPicker.options.length) {
            colorPicker.value = event.key;

            // Trigger the change event if there's an event listener for it
            const changeEvent = new Event('change');
            colorPicker.dispatchEvent(changeEvent);
        }

        // Check if Ctrl+Enter is pressed
        if (event.ctrlKey && event.key === 'Enter') {
            // Call the desired function or action here
            submitTask()

        }

        if (event.key === 'Backspace') {
            // Perform deletion here
            const selectedAnnotations = document.querySelectorAll('.annotation.selected');

            // Get their indices
            const indicesToDelete = Array.from(selectedAnnotations).map(annotation => parseInt(annotation.dataset.index, 10));

            // Remove the annotation element from the DOM
            selectedAnnotations.forEach(annotation => {
                annotation.remove();
            });

            // Remove the corresponding boxes
            boxes = boxes.filter((box, index) => !indicesToDelete.includes(index));

            // Update indices and re-render all remaining annotations
            updateAnnotations();
            updateList();
        }

        if (event.ctrlKey && event.key === 's') {
            // console.log('save');
            updateDatabase()
        }
        // Check if Ctrl+Z is pressed
        if (event.ctrlKey && event.key === 'z') {

            if (boxes.length > 0) {
                // Pop the last box and store it in the undo stack
                const lastBox = boxes.pop();
                undoStack.push(lastBox);

                // Update annotations and list
                updateAnnotations();
                updateList();
            }
        }
        // Implement Ctrl+Shift+Z for redo
        else if (event.ctrlKey && event.shiftKey && event.key === 'Z') {
            if (undoStack.length > 0) {
                // Pop the last undone box and put it back in boxes
                const lastUndoneBox = undoStack.pop();
                boxes.push(lastUndoneBox);

                // Update annotations and list
                updateAnnotations();
                updateList();
            }
        }
    });

});

</script>
{% endblock %}